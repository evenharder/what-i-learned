# 아니메컵 1쿨
Hello, BOJ 2023! 때의 인연이 생각나 대회를 쳤으나, 결과적으로 아쉬움만 잔뜩 남은 대회가 되어버렸다. 연습을 하지 않으니 실력의 하락은 지극히 당연하지만, 내가 이를 못 받아들이고 있는건지 잘 모르겠다. 잔실수도 실력이니까.
- A : Python의 str.count 함수를 이용해 풀었다.
- B : 제법 구현이 복잡했다. 6중 for문까지 끌어와야 했다.
- C : 쉬운 인터랙티브. 칸토어의 대각선 논법 비슷하게 하나씩 다르게 하면 된다.
- D : 처음엔 그리디하게 접근했는데 `5 4 2 10 10 10 10` 같은 경우가 잘 처리가 안 되어서, BST를 이용한 동적 계획법으로 해결했다.
- E : 악몽 그 자체의 문제였다. 결과적으로는 그냥 빠르게 naive를 짜서 맞았는데, 시간 복잡도가 naive가 되나 계속 의심하다가 더 이상한 풀이에 빠져서 1시간 넘게 허비했다. 상처뿐인 문제다. 지금 생각해보니 $10^5 \times 10^2 = 10^8$이라고 생각해서 naive가 안 된다고 생각했나보다. 그냥 안타깝다.
- F : WA를 받지 않는 문제만 최대한 풀고, 그런 문제가 없으면 최소의 WA를 야기하는 문제를 풀고, 그것조차도 없으면 불가능한 문제이다. 어떻게 잘 분류를 하긴 했는데 구현에 시간이 정말 오래 걸렸다. `std::multiset` 대신 `std::set`를 사용해서 한 번 틀렸다.
- G : 기합을 모으는 횟수가 대충 300번 언저리로 보여 동적 계획법으로 
- J : 문제 조건상 오목한 꼭짓점은 하나밖에 있을 수 없고, 그 외에는 선분이 직선 기준으로 대칭인지 거리함수와 외적으로 판별하면 된다. 그 와중에 `vector`를 `resize`하고 `push_back`을 하는 만행을 저질러 한 번 틀렸다.
- I : 개인적으로 구상하고 있던 문제랑 대단히 비슷해서 점화식을 구하고 Berlekamp-Massey에 넣어서 풀려고 했으나 시간이 근소하게 부족했다.

# 아니메컵 2쿨
1쿨보다는 훨씬 나은 성적표를 받아들였다. 여전히 아쉬운 부분이 있었지만 그래도 5시간 12분간 열심히 몰두할 수 있었다.
- A : 각 축에서 최소인 좌표를 찾으면 된다.
- B : 간단한 DP 문제로, 그리디 풀이도 존재한다.
- C : 커피를 담을 시간을 뒤에서부터 그리디하게 계산하고, 앞에서부터 토기를 만들어가 나가면 된다. BOJ 대회에서 처음으로 퍼솔을 했다.
- D : 각 행 별로 연속된 `#` 개수를 확인하고 다른 처리도 조금 해주면 풀 수 있는 문제인데 실수가 조금 나왔다.
- E : 풀이를 잘못 생각했고, 끝날 때까지 구현 실수인가 싶었다. 대회 끝나고 나서야 반례가 생각났다. 2번 틀린 이후 다른 문제를 먼저 봐야겠다 싶어 F번으로 넘어갔다.
- F : 왼쪽에서부터 계속 외치면서 진행하면 된다. $ax+b$ 꼴 선분을 더해서 관리하는 식으로 해결했다.
- G : 나이브하게 DP를 짰으나 시간초과가 나왔다. 이후 3명을 한 번에 움직이지 말고 한 명씩 차례로 움직이도록 코드를 수정해서 해결했다. 옛날에 출제되었던 [ICPC Daejeon 2017 L번](https://www.acmicpc.net/problem/14962)과 비슷한 문제. 
- H : $n$이 85 정도보다 크기만 해도 전체 문자열의 길이가 $10^{18}$을 넘어가기 때문에 그 부분은 맨 앞의 여는 괄호만 벗겨내는데 쓰고, 이후에는 재귀적으로 탐색하면 된다.
- I : 살짝 생각할게 있는 BFS 문제.
- J : 난이도에 비해 푸는데 너무 오랜 시간이 걸렸다. 조금 더 깔끔하게 수식이나 조건을 정리했으면 빨리 풀지 않았을까...
- K : J까지 풀고 대회 종료까지 약 33분 남은 시점에서 K를 볼지 E를 볼지 고심하다가, K가 풀이는 바로 나오는 TSP 비트마스킹 DP + 다익스트라여서 불꽃코딩을 시작했다. 다행스럽게도 대회 종료 5분 전에 AC를 받았다.
나머지 2문제는 아직 생각해보지 않았다.

# 꼬리별

존경해 마지않는 doju님의 문제로, $\sum\limits_{p\text{ is prime},\, p < P} p^k$를 계산해야 한다 ($P < 10^9,\, k \leq 10^3$). 고심하다가 검색을 해서 풀이를 이해하고 풀었다. [Faulhaber's formula](https://en.wikipedia.org/wiki/Faulhaber%27s_formula)와 [Bernoulli numbers](https://en.wikipedia.org/wiki/Bernoulli_number) 를 이용해야 하는데, Bernoulli number가 유리수이기 때문에 작은 $P$에 대해서는 naive하게 계산해줄 필요가 있다. [이 블로그](https://am-just-a-nobody.blogspot.com/2015/11/algorithm-for-summing-all-primes-less.html)에 사살상의 풀이가 다 나와있어 참고를 많이 했다. 포함배제의 원리를 대단히 정교하게 활용하여 계산해낸다.
구현을 했음에도 불구하고 시간초과가 계속 나서 온갖 최적화를 시도했다. 알고보니 bottleneck이 전혀 예상치 못했으나 코드를 꼼꼼하게 분석했다면 충분히 도출해낼 수 있었던 위치에 있었다. 해당 코드를 고치니 시간 초과 코드가 1.3초에 돌았고, 처음 코드에서 이 부분만 수정하니 4.4초에 돌았다. 풀면서 정수론과 조금 친숙해진 것 같다.
